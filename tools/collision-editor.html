<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Splat to Collision Mesh</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #1a1a2e; 
      color: #eee;
      overflow: hidden;
    }
    #canvas-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 0;
    }
    canvas { 
      display: block; 
      touch-action: none;
    }
    
    /* Toolbar */
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 100;
      max-width: 280px;
    }
    .toolbar-group {
      background: rgba(30, 30, 50, 0.95);
      border-radius: 8px;
      padding: 12px;
      border: 1px solid #3a3a5a;
    }
    .toolbar-group h3 {
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 8px;
      letter-spacing: 1px;
    }
    .btn {
      background: #2a2a4a;
      border: 1px solid #4a4a6a;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      display: block;
      width: 100%;
      margin-bottom: 4px;
    }
    .btn:hover { background: #3a3a6a; border-color: #6a6a9a; }
    .btn:active { background: #4a4a7a; }
    .btn.primary { background: #4a6aaa; border-color: #6a8aca; }
    .btn.primary:hover { background: #5a7aba; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .prop-row {
      margin-bottom: 10px;
    }
    .prop-row label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }
    .prop-row input[type="range"] {
      width: 100%;
    }
    .prop-row .value {
      font-size: 11px;
      color: #6a8aca;
      float: right;
    }
    
    .stats-row {
      font-size: 11px;
      color: #888;
      margin-bottom: 4px;
    }
    .stats-row .label { color: #666; }
    .stats-row .value { color: #6a8aca; }
    
    /* Status bar */
    #status {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(30, 30, 50, 0.9);
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 12px;
      color: #888;
      z-index: 100;
    }
    #status .hint { color: #6a8aca; }
    
    /* Progress */
    .progress-bar {
      height: 4px;
      background: #2a2a4a;
      border-radius: 2px;
      margin-top: 8px;
      overflow: hidden;
    }
    .progress-bar .fill {
      height: 100%;
      background: #4a9aff;
      width: 0%;
      transition: width 0.3s;
    }
    
    /* Toggle */
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .toggle-row label { font-size: 12px; color: #888; }
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="toolbar">
    <div class="toolbar-group">
      <h3>1. Load Splat</h3>
      <button class="btn" onclick="document.getElementById('file-input').click()">Load .spz file</button>
      <input type="file" id="file-input" accept=".spz,.ply,.splat" style="display:none">
      <div id="splat-stats" style="margin-top: 8px;">
        <div class="stats-row"><span class="label">Splats:</span> <span class="value" id="stat-splats">-</span></div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>2. Downsample</h3>
      <div class="prop-row">
        <label>Opacity Cutoff <span class="value" id="opacity-threshold-value">0.05</span></label>
        <input type="range" id="opacity-threshold" min="0" max="1" step="0.01" value="0.05" oninput="updateOpacityThreshold()">
      </div>
      <div class="prop-row">
        <label>Sample Rate <span class="value" id="sample-rate-value">10%</span></label>
        <input type="range" id="sample-rate" min="1" max="100" value="10" oninput="updateSampleRate()">
      </div>
      <div class="stats-row"><span class="label">After opacity:</span> <span class="value" id="stat-filtered">-</span></div>
      <div class="stats-row"><span class="label">Points used:</span> <span class="value" id="stat-points">-</span></div>
    </div>

    <div class="toolbar-group">
      <h3>2b. Controls</h3>
      <div class="prop-row">
        <label>Move Speed <span class="value" id="move-speed-value">1.0</span></label>
        <input type="range" id="move-speed" min="0.1" max="5" step="0.1" value="1" oninput="updateMoveSpeed()">
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>3. Generate Mesh</h3>
      <div class="prop-row">
        <label>Voxel Resolution <span class="value" id="voxel-res-value">50</span></label>
        <input type="range" id="voxel-resolution" min="20" max="500" value="50" oninput="updateVoxelRes()">
      </div>
      <div class="prop-row">
        <label>Fill Radius <span class="value" id="fill-radius-value">2.0</span></label>
        <input type="range" id="fill-radius" min="0.1" max="5" value="2" step="0.1" oninput="updateFillRadius()">
      </div>
      <button class="btn primary" id="generate-btn" onclick="generateMesh()" disabled>Generate Mesh</button>
      <div class="progress-bar"><div class="fill" id="progress"></div></div>
      <div class="stats-row" style="margin-top: 8px;"><span class="label">Vertices:</span> <span class="value" id="stat-verts">-</span></div>
      <div class="stats-row"><span class="label">Triangles:</span> <span class="value" id="stat-tris">-</span></div>
    </div>
    
    <div class="toolbar-group">
      <h3>4. Preview</h3>
      <div class="toggle-row">
        <input type="checkbox" id="show-points" checked onchange="togglePoints()">
        <label for="show-points">Show sample points</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="show-mesh" checked onchange="toggleMesh()">
        <label for="show-mesh">Show mesh</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="show-wireframe" onchange="toggleWireframe()">
        <label for="show-wireframe">Wireframe mode</label>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>5. Erase Tool</h3>
      <div class="toggle-row">
        <input type="checkbox" id="erase-mode" onchange="toggleEraseMode()">
        <label for="erase-mode">Enable Erase Mode</label>
      </div>
      <div class="prop-row">
        <label>Eraser Size <span class="value" id="eraser-size-value">0.5</span></label>
        <input type="range" id="eraser-size" min="0.1" max="3" step="0.1" value="0.5" oninput="updateEraserSize()">
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>6. Export</h3>
      <button class="btn primary" id="export-btn" onclick="exportGLB()" disabled>Export .glb</button>
    </div>
  </div>
  
  <div id="status">
    <span class="hint">Controls:</span> SparkControls (click/drag + WASD). This matches the main app FPS feel.
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
      "@sparkjsdev/spark": "../lib/spark.module.js"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
    import { SplatMesh, SparkControls } from '@sparkjsdev/spark';
    
    // ========== Scene Setup ==========
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 10000);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    
    // SparkControls (FPS-like) controlling a localFrame
    const localFrame = new THREE.Group();
    scene.add(localFrame);
    localFrame.add(camera);
    localFrame.position.set(5, 5, 5);

    let moveSpeedScalar = 1.0;

    const controls = new SparkControls({
      renderer,
      canvas: renderer.domElement,
    });

    // Optional yaw with Q/E keys
    const keyState = { q: false, e: false };
    const yawSpeed = 0.02; // radians per frame baseline

    document.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k === 'q' || k === 'e') keyState[k] = true;
    });
    document.addEventListener('keyup', (e) => {
      const k = e.key.toLowerCase();
      if (k === 'q' || k === 'e') keyState[k] = false;
    });
    
    // Grid helper
    const grid = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
    scene.add(grid);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    
    // ========== State ==========
    let allSplats = []; // { pos: Vector3, alpha: number }
    let sampledPositions = []; // Downsampled positions (Vector3)
    let pointsCloud = null; // THREE.Points for visualization
    let generatedMesh = null; // Generated collision mesh
    
    // ========== Eraser State ==========
    let eraserMode = false;
    let eraserSize = 0.5;
    let eraserSphere = null;
    let isErasing = false;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // Create eraser sphere (initially hidden)
    const eraserGeometry = new THREE.SphereGeometry(1, 16, 16);
    const eraserMaterial = new THREE.MeshBasicMaterial({
      color: 0xff4444,
      transparent: true,
      opacity: 0.3,
      depthTest: true,
      depthWrite: false
    });
    eraserSphere = new THREE.Mesh(eraserGeometry, eraserMaterial);
    eraserSphere.visible = false;
    eraserSphere.scale.setScalar(eraserSize); // Set initial size
    scene.add(eraserSphere);
    
    // Add wireframe outline to eraser sphere for better visibility
    const eraserWireframe = new THREE.LineSegments(
      new THREE.WireframeGeometry(eraserGeometry),
      new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 0.8, transparent: true })
    );
    eraserSphere.add(eraserWireframe);
    
    // ========== File Loading ==========
    const fileInput = document.getElementById('file-input');
    
    // Drag and drop on document
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const file = e.dataTransfer.files[0];
      if (file && (file.name.endsWith('.spz') || file.name.endsWith('.ply') || file.name.endsWith('.splat'))) {
        await loadSplatFile(file);
      }
    });
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) await loadSplatFile(file);
    });
    
    async function loadSplatFile(file) {
      try {
        setStatus('Loading splat file...');
        console.log('Loading:', file.name, file.size, 'bytes');
        
        const arrayBuffer = await file.arrayBuffer();
        const fileBytes = new Uint8Array(arrayBuffer);
        
        // Create SplatMesh to parse the file
        const splatMesh = new SplatMesh({
          fileBytes,
          fileName: file.name
        });
        
        await splatMesh.initialized;
        
        // Wait a frame for data to be ready
        await new Promise(resolve => requestAnimationFrame(resolve));
        
        const packedSplats = splatMesh.packedSplats;
        const numSplats = packedSplats?.numSplats || 0;
        
        console.log('Loaded', numSplats, 'splats');
        document.getElementById('stat-splats').textContent = numSplats.toLocaleString();
        
        if (numSplats === 0) {
          setStatus('Error: No splats found in file');
          return;
        }
        
        // Extract all splat positions + opacity
        allSplats = [];
        for (let i = 0; i < numSplats; i++) {
          const splat = packedSplats.getSplat(i);
          const pos = splat.center;
          if (pos && isFinite(pos.x) && isFinite(pos.y) && isFinite(pos.z)) {
            // Spark splats carry opacity; fall back to rgba.a if needed
            const opacity = splat.opacity ?? splat.rgba?.a ?? 1;
            allSplats.push({ pos: new THREE.Vector3(pos.x, pos.y, pos.z), alpha: opacity });
          }
        }
        
        console.log('Extracted', allSplats.length, 'valid positions');
        
        // Dispose the SplatMesh - we only needed the positions
        splatMesh.dispose();
        
        // Update sample and center camera
        updateSampledPositions();
        centerCameraOnPoints();
        
        // Enable generate button
        document.getElementById('generate-btn').disabled = false;
        
        setStatus(`Loaded ${numSplats.toLocaleString()} splats. Adjust sampling and generate mesh.`);
        
      } catch (err) {
        console.error('Error loading splat:', err);
        setStatus('Error: ' + err.message);
      }
    }
    
    // ========== Sampling ==========
    function updateSampledPositions() {
      const sampleRate = parseInt(document.getElementById('sample-rate').value) / 100;
      const opacityThreshold = parseFloat(document.getElementById('opacity-threshold').value);

      // Filter by opacity
      const filtered = allSplats.filter(s => s.alpha >= opacityThreshold);
      document.getElementById('stat-filtered').textContent = filtered.length.toLocaleString();

      const numSamples = Math.max(1, Math.floor(filtered.length * sampleRate));
      
      // Uniform step sampling
      sampledPositions = [];
      const step = Math.max(1, Math.floor(filtered.length / numSamples));
      
      for (let i = 0; i < filtered.length; i += step) {
        sampledPositions.push(filtered[i].pos);
      }
      
      document.getElementById('stat-points').textContent = sampledPositions.length.toLocaleString();
      
      // Update point cloud visualization
      updatePointCloud();
    }
    
    function updatePointCloud() {
      if (pointsCloud) {
        scene.remove(pointsCloud);
        pointsCloud.geometry.dispose();
        pointsCloud.material.dispose();
      }
      
      if (sampledPositions.length === 0) return;
      
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(sampledPositions.length * 3);
      
      for (let i = 0; i < sampledPositions.length; i++) {
        positions[i * 3] = sampledPositions[i].x;
        positions[i * 3 + 1] = sampledPositions[i].y;
        positions[i * 3 + 2] = sampledPositions[i].z;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const material = new THREE.PointsMaterial({
        color: 0x4a9aff,
        size: 0.02,
        sizeAttenuation: true
      });
      
      pointsCloud = new THREE.Points(geometry, material);
      pointsCloud.visible = document.getElementById('show-points').checked;
      scene.add(pointsCloud);
    }
    
    function centerCameraOnPoints() {
      if (sampledPositions.length === 0) return;
      
      const bounds = new THREE.Box3();
      for (const pos of sampledPositions) {
        bounds.expandByPoint(pos);
      }
      
      const center = bounds.getCenter(new THREE.Vector3());
      const size = bounds.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 10;
      
      localFrame.position.set(
        center.x + maxDim * 0.8,
        center.y + maxDim * 0.5,
        center.z + maxDim * 0.8
      );
      // Face the center
      //localFrame.lookAt(center);
    }
    
    // ========== Mesh Generation (Marching Cubes) ==========
    async function generateMesh() {
      if (sampledPositions.length === 0) {
        setStatus('No points to process. Load a splat file first.');
        return;
      }
      
      setStatus('Generating mesh...');
      setProgress(0);
      
      // Allow UI to update
      await new Promise(resolve => setTimeout(resolve, 50));
      
      const resolution = parseInt(document.getElementById('voxel-resolution').value);
      const fillRadius = parseFloat(document.getElementById('fill-radius').value);
      
      try {
        // Step 1: Compute bounds
        const bounds = new THREE.Box3();
        for (const pos of sampledPositions) {
          bounds.expandByPoint(pos);
        }
        bounds.expandByScalar(0.5); // Padding
        
        const size = bounds.getSize(new THREE.Vector3());
        const maxSize = Math.max(size.x, size.y, size.z);
        const voxelSize = maxSize / resolution;
        
        const nx = Math.ceil(size.x / voxelSize) + 2;
        const ny = Math.ceil(size.y / voxelSize) + 2;
        const nz = Math.ceil(size.z / voxelSize) + 2;
        
        console.log('Voxel grid:', nx, 'x', ny, 'x', nz);
        setProgress(10);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Step 2: Create voxel grid (density field)
        const voxels = new Float32Array(nx * ny * nz);
        
        // Fill voxels based on point positions
        const fillRadiusInt = Math.ceil(fillRadius);
        
        for (let i = 0; i < sampledPositions.length; i++) {
          const pos = sampledPositions[i];
          
          // Convert to voxel coordinates (can be fractional)
          const vxf = (pos.x - bounds.min.x) / voxelSize;
          const vyf = (pos.y - bounds.min.y) / voxelSize;
          const vzf = (pos.z - bounds.min.z) / voxelSize;
          
          const vx = Math.floor(vxf);
          const vy = Math.floor(vyf);
          const vz = Math.floor(vzf);
          
          // Fill neighboring cells with falloff
          for (let dx = -fillRadiusInt; dx <= fillRadiusInt; dx++) {
            for (let dy = -fillRadiusInt; dy <= fillRadiusInt; dy++) {
              for (let dz = -fillRadiusInt; dz <= fillRadiusInt; dz++) {
                const ix = vx + dx;
                const iy = vy + dy;
                const iz = vz + dz;
                
                if (ix >= 0 && ix < nx && iy >= 0 && iy < ny && iz >= 0 && iz < nz) {
                  // Calculate actual distance from the point (in voxel units)
                  const actualDx = ix - vxf + 0.5; // Distance to voxel center
                  const actualDy = iy - vyf + 0.5;
                  const actualDz = iz - vzf + 0.5;
                  const dist = Math.sqrt(actualDx*actualDx + actualDy*actualDy + actualDz*actualDz);
                  
                  // Smooth falloff based on fill radius
                  const weight = Math.max(0, 1 - dist / (fillRadius + 0.5));
                  const idx = ix + iy * nx + iz * nx * ny;
                  voxels[idx] = Math.max(voxels[idx], weight);
                }
              }
            }
          }
          
          // Update progress occasionally
          if (i % 10000 === 0) {
            setProgress(10 + (i / sampledPositions.length) * 30);
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }
        
        setProgress(40);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Step 3: Marching cubes
        console.log('Running marching cubes...');
        const { vertices, indices } = marchingCubes(voxels, nx, ny, nz, bounds, voxelSize, 0.5);
        
        setProgress(80);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        if (vertices.length === 0) {
          setStatus('No mesh generated. Try increasing fill radius or sample rate.');
          setProgress(0);
          return;
        }
        
        // Step 4: Create mesh
        if (generatedMesh) {
          scene.remove(generatedMesh);
          generatedMesh.geometry.dispose();
          generatedMesh.material.dispose();
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshStandardMaterial({
          color: 0x88aaff,
          side: THREE.DoubleSide,
          wireframe: document.getElementById('show-wireframe').checked
        });
        
        generatedMesh = new THREE.Mesh(geometry, material);
        generatedMesh.visible = document.getElementById('show-mesh').checked;
        scene.add(generatedMesh);
        
        // Update stats
        document.getElementById('stat-verts').textContent = (vertices.length / 3).toLocaleString();
        document.getElementById('stat-tris').textContent = (indices.length / 3).toLocaleString();
        
        // Enable export
        document.getElementById('export-btn').disabled = false;
        
        setProgress(100);
        setStatus(`Generated mesh with ${(vertices.length/3).toLocaleString()} vertices, ${(indices.length/3).toLocaleString()} triangles`);
        
        setTimeout(() => setProgress(0), 1000);
        
      } catch (err) {
        console.error('Error generating mesh:', err);
        setStatus('Error: ' + err.message);
        setProgress(0);
      }
    }
    
    // ========== Marching Cubes Implementation ==========
    function marchingCubes(voxels, nx, ny, nz, bounds, voxelSize, isoLevel) {
      const vertices = [];
      const indices = [];
      const vertexMap = new Map(); // For vertex deduplication
      
      function getVoxel(ix, iy, iz) {
        if (ix < 0 || ix >= nx || iy < 0 || iy >= ny || iz < 0 || iz >= nz) return 0;
        return voxels[ix + iy * nx + iz * nx * ny];
      }
      
      function getPosition(ix, iy, iz) {
        return new THREE.Vector3(
          bounds.min.x + ix * voxelSize,
          bounds.min.y + iy * voxelSize,
          bounds.min.z + iz * voxelSize
        );
      }
      
      function interpolateVertex(p1, p2, v1, v2) {
        if (Math.abs(isoLevel - v1) < 0.00001) return p1.clone();
        if (Math.abs(isoLevel - v2) < 0.00001) return p2.clone();
        if (Math.abs(v1 - v2) < 0.00001) return p1.clone();
        const t = (isoLevel - v1) / (v2 - v1);
        return new THREE.Vector3().lerpVectors(p1, p2, t);
      }
      
      function addVertex(v) {
        const key = `${v.x.toFixed(5)},${v.y.toFixed(5)},${v.z.toFixed(5)}`;
        if (vertexMap.has(key)) {
          return vertexMap.get(key);
        }
        const idx = vertices.length / 3;
        vertices.push(v.x, v.y, v.z);
        vertexMap.set(key, idx);
        return idx;
      }
      
      // Process each voxel cell
      // Standard marching cubes vertex ordering (Paul Bourke convention):
      //        4-----------5
      //       /|          /|
      //      / |         / |
      //     /  |        /  |
      //    7-----------6   |
      //    |   |       |   |
      //    |   0-------|---1
      //    |  /        |  /
      //    | /         | /
      //    |/          |/
      //    3-----------2
      // 
      // Vertex positions: 0:(0,0,0), 1:(1,0,0), 2:(1,0,1), 3:(0,0,1)
      //                   4:(0,1,0), 5:(1,1,0), 6:(1,1,1), 7:(0,1,1)
      
      for (let iz = 0; iz < nz - 1; iz++) {
        for (let iy = 0; iy < ny - 1; iy++) {
          for (let ix = 0; ix < nx - 1; ix++) {
            // Get 8 corner values - using standard marching cubes vertex ordering
            const v = [
              getVoxel(ix, iy, iz),           // 0: (0,0,0)
              getVoxel(ix + 1, iy, iz),       // 1: (1,0,0)
              getVoxel(ix + 1, iy, iz + 1),   // 2: (1,0,1)
              getVoxel(ix, iy, iz + 1),       // 3: (0,0,1)
              getVoxel(ix, iy + 1, iz),       // 4: (0,1,0)
              getVoxel(ix + 1, iy + 1, iz),   // 5: (1,1,0)
              getVoxel(ix + 1, iy + 1, iz + 1), // 6: (1,1,1)
              getVoxel(ix, iy + 1, iz + 1)    // 7: (0,1,1)
            ];
            
            // Calculate cube index
            let cubeIndex = 0;
            for (let i = 0; i < 8; i++) {
              if (v[i] > isoLevel) cubeIndex |= (1 << i);
            }
            
            // Skip empty or full cubes
            if (cubeIndex === 0 || cubeIndex === 255) continue;
            
            // Get corner positions - matching vertex ordering above
            const p = [
              getPosition(ix, iy, iz),           // 0
              getPosition(ix + 1, iy, iz),       // 1
              getPosition(ix + 1, iy, iz + 1),   // 2
              getPosition(ix, iy, iz + 1),       // 3
              getPosition(ix, iy + 1, iz),       // 4
              getPosition(ix + 1, iy + 1, iz),   // 5
              getPosition(ix + 1, iy + 1, iz + 1), // 6
              getPosition(ix, iy + 1, iz + 1)    // 7
            ];
            
            // Edge table - which edges are crossed
            const edges = EDGE_TABLE[cubeIndex];
            if (edges === 0) continue;
            
            // Interpolate vertices on edges
            const edgeVertices = new Array(12);
            
            if (edges & 1) edgeVertices[0] = interpolateVertex(p[0], p[1], v[0], v[1]);
            if (edges & 2) edgeVertices[1] = interpolateVertex(p[1], p[2], v[1], v[2]);
            if (edges & 4) edgeVertices[2] = interpolateVertex(p[2], p[3], v[2], v[3]);
            if (edges & 8) edgeVertices[3] = interpolateVertex(p[3], p[0], v[3], v[0]);
            if (edges & 16) edgeVertices[4] = interpolateVertex(p[4], p[5], v[4], v[5]);
            if (edges & 32) edgeVertices[5] = interpolateVertex(p[5], p[6], v[5], v[6]);
            if (edges & 64) edgeVertices[6] = interpolateVertex(p[6], p[7], v[6], v[7]);
            if (edges & 128) edgeVertices[7] = interpolateVertex(p[7], p[4], v[7], v[4]);
            if (edges & 256) edgeVertices[8] = interpolateVertex(p[0], p[4], v[0], v[4]);
            if (edges & 512) edgeVertices[9] = interpolateVertex(p[1], p[5], v[1], v[5]);
            if (edges & 1024) edgeVertices[10] = interpolateVertex(p[2], p[6], v[2], v[6]);
            if (edges & 2048) edgeVertices[11] = interpolateVertex(p[3], p[7], v[3], v[7]);
            
            // Create triangles from tri table
            const triData = TRI_TABLE[cubeIndex];
            for (let i = 0; triData[i] !== -1; i += 3) {
              const v0 = edgeVertices[triData[i]];
              const v1 = edgeVertices[triData[i + 1]];
              const v2 = edgeVertices[triData[i + 2]];
              
              if (v0 && v1 && v2) {
                const i0 = addVertex(v0);
                const i1 = addVertex(v1);
                const i2 = addVertex(v2);
                indices.push(i0, i1, i2);
              }
            }
          }
        }
      }
      
      return { vertices, indices };
    }
    
    // Marching cubes lookup tables (standard tables)
    const EDGE_TABLE = [
      0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
      0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
      0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
      0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
      0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
      0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
      0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
      0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
      0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
      0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
      0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
      0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
      0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
      0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
      0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
      0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
    ];
    
    // Triangle table - for each cube configuration, list of edge indices forming triangles
    // -1 terminates each configuration
    const TRI_TABLE = [
      [-1],
      [0, 8, 3, -1],
      [0, 1, 9, -1],
      [1, 8, 3, 9, 8, 1, -1],
      [1, 2, 10, -1],
      [0, 8, 3, 1, 2, 10, -1],
      [9, 2, 10, 0, 2, 9, -1],
      [2, 8, 3, 2, 10, 8, 10, 9, 8, -1],
      [3, 11, 2, -1],
      [0, 11, 2, 8, 11, 0, -1],
      [1, 9, 0, 2, 3, 11, -1],
      [1, 11, 2, 1, 9, 11, 9, 8, 11, -1],
      [3, 10, 1, 11, 10, 3, -1],
      [0, 10, 1, 0, 8, 10, 8, 11, 10, -1],
      [3, 9, 0, 3, 11, 9, 11, 10, 9, -1],
      [9, 8, 10, 10, 8, 11, -1],
      [4, 7, 8, -1],
      [4, 3, 0, 7, 3, 4, -1],
      [0, 1, 9, 8, 4, 7, -1],
      [4, 1, 9, 4, 7, 1, 7, 3, 1, -1],
      [1, 2, 10, 8, 4, 7, -1],
      [3, 4, 7, 3, 0, 4, 1, 2, 10, -1],
      [9, 2, 10, 9, 0, 2, 8, 4, 7, -1],
      [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1],
      [8, 4, 7, 3, 11, 2, -1],
      [11, 4, 7, 11, 2, 4, 2, 0, 4, -1],
      [9, 0, 1, 8, 4, 7, 2, 3, 11, -1],
      [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1],
      [3, 10, 1, 3, 11, 10, 7, 8, 4, -1],
      [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1],
      [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1],
      [4, 7, 11, 4, 11, 9, 9, 11, 10, -1],
      [9, 5, 4, -1],
      [9, 5, 4, 0, 8, 3, -1],
      [0, 5, 4, 1, 5, 0, -1],
      [8, 5, 4, 8, 3, 5, 3, 1, 5, -1],
      [1, 2, 10, 9, 5, 4, -1],
      [3, 0, 8, 1, 2, 10, 4, 9, 5, -1],
      [5, 2, 10, 5, 4, 2, 4, 0, 2, -1],
      [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1],
      [9, 5, 4, 2, 3, 11, -1],
      [0, 11, 2, 0, 8, 11, 4, 9, 5, -1],
      [0, 5, 4, 0, 1, 5, 2, 3, 11, -1],
      [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1],
      [10, 3, 11, 10, 1, 3, 9, 5, 4, -1],
      [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1],
      [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1],
      [5, 4, 8, 5, 8, 10, 10, 8, 11, -1],
      [9, 7, 8, 5, 7, 9, -1],
      [9, 3, 0, 9, 5, 3, 5, 7, 3, -1],
      [0, 7, 8, 0, 1, 7, 1, 5, 7, -1],
      [1, 5, 3, 3, 5, 7, -1],
      [9, 7, 8, 9, 5, 7, 10, 1, 2, -1],
      [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1],
      [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1],
      [2, 10, 5, 2, 5, 3, 3, 5, 7, -1],
      [7, 9, 5, 7, 8, 9, 3, 11, 2, -1],
      [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1],
      [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1],
      [11, 2, 1, 11, 1, 7, 7, 1, 5, -1],
      [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1],
      [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
      [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
      [11, 10, 5, 7, 11, 5, -1],
      [10, 6, 5, -1],
      [0, 8, 3, 5, 10, 6, -1],
      [9, 0, 1, 5, 10, 6, -1],
      [1, 8, 3, 1, 9, 8, 5, 10, 6, -1],
      [1, 6, 5, 2, 6, 1, -1],
      [1, 6, 5, 1, 2, 6, 3, 0, 8, -1],
      [9, 6, 5, 9, 0, 6, 0, 2, 6, -1],
      [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1],
      [2, 3, 11, 10, 6, 5, -1],
      [11, 0, 8, 11, 2, 0, 10, 6, 5, -1],
      [0, 1, 9, 2, 3, 11, 5, 10, 6, -1],
      [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1],
      [6, 3, 11, 6, 5, 3, 5, 1, 3, -1],
      [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1],
      [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1],
      [6, 5, 9, 6, 9, 11, 11, 9, 8, -1],
      [5, 10, 6, 4, 7, 8, -1],
      [4, 3, 0, 4, 7, 3, 6, 5, 10, -1],
      [1, 9, 0, 5, 10, 6, 8, 4, 7, -1],
      [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1],
      [6, 1, 2, 6, 5, 1, 4, 7, 8, -1],
      [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1],
      [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1],
      [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
      [3, 11, 2, 7, 8, 4, 10, 6, 5, -1],
      [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1],
      [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1],
      [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
      [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1],
      [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
      [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
      [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1],
      [10, 4, 9, 6, 4, 10, -1],
      [4, 10, 6, 4, 9, 10, 0, 8, 3, -1],
      [10, 0, 1, 10, 6, 0, 6, 4, 0, -1],
      [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1],
      [1, 4, 9, 1, 2, 4, 2, 6, 4, -1],
      [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1],
      [0, 2, 4, 4, 2, 6, -1],
      [8, 3, 2, 8, 2, 4, 4, 2, 6, -1],
      [10, 4, 9, 10, 6, 4, 11, 2, 3, -1],
      [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1],
      [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1],
      [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
      [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1],
      [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
      [3, 11, 6, 3, 6, 0, 0, 6, 4, -1],
      [6, 4, 8, 11, 6, 8, -1],
      [7, 10, 6, 7, 8, 10, 8, 9, 10, -1],
      [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1],
      [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1],
      [10, 6, 7, 10, 7, 1, 1, 7, 3, -1],
      [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1],
      [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
      [7, 8, 0, 7, 0, 6, 6, 0, 2, -1],
      [7, 3, 2, 6, 7, 2, -1],
      [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1],
      [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
      [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
      [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1],
      [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
      [0, 9, 1, 11, 6, 7, -1],
      [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1],
      [7, 11, 6, -1],
      [7, 6, 11, -1],
      [3, 0, 8, 11, 7, 6, -1],
      [0, 1, 9, 11, 7, 6, -1],
      [8, 1, 9, 8, 3, 1, 11, 7, 6, -1],
      [10, 1, 2, 6, 11, 7, -1],
      [1, 2, 10, 3, 0, 8, 6, 11, 7, -1],
      [2, 9, 0, 2, 10, 9, 6, 11, 7, -1],
      [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1],
      [7, 2, 3, 6, 2, 7, -1],
      [7, 0, 8, 7, 6, 0, 6, 2, 0, -1],
      [2, 7, 6, 2, 3, 7, 0, 1, 9, -1],
      [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1],
      [10, 7, 6, 10, 1, 7, 1, 3, 7, -1],
      [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1],
      [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1],
      [7, 6, 10, 7, 10, 8, 8, 10, 9, -1],
      [6, 8, 4, 11, 8, 6, -1],
      [3, 6, 11, 3, 0, 6, 0, 4, 6, -1],
      [8, 6, 11, 8, 4, 6, 9, 0, 1, -1],
      [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1],
      [6, 8, 4, 6, 11, 8, 2, 10, 1, -1],
      [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1],
      [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1],
      [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
      [8, 2, 3, 8, 4, 2, 4, 6, 2, -1],
      [0, 4, 2, 4, 6, 2, -1],
      [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1],
      [1, 9, 4, 1, 4, 2, 2, 4, 6, -1],
      [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1],
      [10, 1, 0, 10, 0, 6, 6, 0, 4, -1],
      [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
      [10, 9, 4, 6, 10, 4, -1],
      [4, 9, 5, 7, 6, 11, -1],
      [0, 8, 3, 4, 9, 5, 11, 7, 6, -1],
      [5, 0, 1, 5, 4, 0, 7, 6, 11, -1],
      [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1],
      [9, 5, 4, 10, 1, 2, 7, 6, 11, -1],
      [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1],
      [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1],
      [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
      [7, 2, 3, 7, 6, 2, 5, 4, 9, -1],
      [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1],
      [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1],
      [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
      [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1],
      [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
      [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
      [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1],
      [6, 9, 5, 6, 11, 9, 11, 8, 9, -1],
      [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1],
      [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1],
      [6, 11, 3, 6, 3, 5, 5, 3, 1, -1],
      [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1],
      [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
      [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
      [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1],
      [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1],
      [9, 5, 6, 9, 6, 0, 0, 6, 2, -1],
      [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
      [1, 5, 6, 2, 1, 6, -1],
      [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
      [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1],
      [0, 3, 8, 5, 6, 10, -1],
      [10, 5, 6, -1],
      [11, 5, 10, 7, 5, 11, -1],
      [11, 5, 10, 11, 7, 5, 8, 3, 0, -1],
      [5, 11, 7, 5, 10, 11, 1, 9, 0, -1],
      [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1],
      [11, 1, 2, 11, 7, 1, 7, 5, 1, -1],
      [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1],
      [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1],
      [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
      [2, 5, 10, 2, 3, 5, 3, 7, 5, -1],
      [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1],
      [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1],
      [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
      [1, 3, 5, 3, 7, 5, -1],
      [0, 8, 7, 0, 7, 1, 1, 7, 5, -1],
      [9, 0, 3, 9, 3, 5, 5, 3, 7, -1],
      [9, 8, 7, 5, 9, 7, -1],
      [5, 8, 4, 5, 10, 8, 10, 11, 8, -1],
      [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1],
      [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1],
      [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
      [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1],
      [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
      [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
      [9, 4, 5, 2, 11, 3, -1],
      [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1],
      [5, 10, 2, 5, 2, 4, 4, 2, 0, -1],
      [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
      [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1],
      [8, 4, 5, 8, 5, 3, 3, 5, 1, -1],
      [0, 4, 5, 1, 0, 5, -1],
      [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1],
      [9, 4, 5, -1],
      [4, 11, 7, 4, 9, 11, 9, 10, 11, -1],
      [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1],
      [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1],
      [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
      [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1],
      [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
      [11, 7, 4, 11, 4, 2, 2, 4, 0, -1],
      [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1],
      [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1],
      [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
      [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
      [1, 10, 2, 8, 7, 4, -1],
      [4, 9, 1, 4, 1, 7, 7, 1, 3, -1],
      [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1],
      [4, 0, 3, 7, 4, 3, -1],
      [4, 8, 7, -1],
      [9, 10, 8, 10, 11, 8, -1],
      [3, 0, 9, 3, 9, 11, 11, 9, 10, -1],
      [0, 1, 10, 0, 10, 8, 8, 10, 11, -1],
      [3, 1, 10, 11, 3, 10, -1],
      [1, 2, 11, 1, 11, 9, 9, 11, 8, -1],
      [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1],
      [0, 2, 11, 8, 0, 11, -1],
      [3, 2, 11, -1],
      [2, 3, 8, 2, 8, 10, 10, 8, 9, -1],
      [9, 10, 2, 0, 9, 2, -1],
      [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1],
      [1, 10, 2, -1],
      [1, 3, 8, 9, 1, 8, -1],
      [0, 9, 1, -1],
      [0, 3, 8, -1],
      [-1]
    ];
    
    // ========== UI Functions ==========
    window.updateSampleRate = function() {
      const val = document.getElementById('sample-rate').value;
      document.getElementById('sample-rate-value').textContent = val + '%';
      updateSampledPositions();
    };

    window.updateOpacityThreshold = function() {
      const val = document.getElementById('opacity-threshold').value;
      document.getElementById('opacity-threshold-value').textContent = parseFloat(val).toFixed(2);
      updateSampledPositions();
    };

    window.updateMoveSpeed = function() {
      const val = parseFloat(document.getElementById('move-speed').value);
      moveSpeedScalar = val;
      document.getElementById('move-speed-value').textContent = val.toFixed(1);
    };
    
    window.updateVoxelRes = function() {
      const val = document.getElementById('voxel-resolution').value;
      document.getElementById('voxel-res-value').textContent = val;
    };
    
    window.updateFillRadius = function() {
      const val = parseFloat(document.getElementById('fill-radius').value);
      document.getElementById('fill-radius-value').textContent = val.toFixed(1);
    };
    
    // ========== Eraser Functions ==========
    window.toggleEraseMode = function() {
      eraserMode = document.getElementById('erase-mode').checked;
      eraserSphere.visible = eraserMode;
      
      // Only disable pointer/mouse controls when in erase mode, keep WASD movement
      if (controls.pointerControls) controls.pointerControls.enable = !eraserMode;
      // fpsMovement (WASD) stays enabled so you can navigate while erasing
      
      if (eraserMode) {
        setStatus('Erase mode: Click and drag on mesh to erase (WASD still moves camera)');
        container.style.cursor = 'crosshair';
      } else {
        setStatus('Erase mode disabled');
        container.style.cursor = 'grab';
      }
    };
    
    window.updateEraserSize = function() {
      eraserSize = parseFloat(document.getElementById('eraser-size').value);
      document.getElementById('eraser-size-value').textContent = eraserSize.toFixed(1);
      eraserSphere.scale.setScalar(eraserSize);
    };
    
    // Update eraser sphere position based on mouse/raycast
    function updateEraserPosition(event) {
      if (!eraserMode) return;
      
      const rect = container.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // First try to intersect with the generated mesh
      if (generatedMesh && generatedMesh.visible) {
        const intersects = raycaster.intersectObject(generatedMesh);
        if (intersects.length > 0) {
          eraserSphere.position.copy(intersects[0].point);
          return;
        }
      }
      
      // If no mesh hit, place sphere at a fixed distance along ray
      const point = raycaster.ray.at(10, new THREE.Vector3());
      eraserSphere.position.copy(point);
    }
    
    // Erase triangles within the eraser sphere
    function eraseAtPosition() {
      if (!eraserMode || !generatedMesh) return;
      
      const geometry = generatedMesh.geometry;
      const position = geometry.getAttribute('position');
      const index = geometry.getIndex();
      
      if (!index) return; // Non-indexed geometry not supported
      
      const eraserPos = eraserSphere.position;
      const eraserRadiusSq = eraserSize * eraserSize;
      
      const indices = index.array;
      const positions = position.array;
      const newIndices = [];
      
      // Check each triangle
      for (let i = 0; i < indices.length; i += 3) {
        const i0 = indices[i];
        const i1 = indices[i + 1];
        const i2 = indices[i + 2];
        
        // Get triangle vertices
        const v0 = new THREE.Vector3(positions[i0 * 3], positions[i0 * 3 + 1], positions[i0 * 3 + 2]);
        const v1 = new THREE.Vector3(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
        const v2 = new THREE.Vector3(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
        
        // Check if any vertex is within eraser sphere
        const inSphere = 
          v0.distanceToSquared(eraserPos) < eraserRadiusSq ||
          v1.distanceToSquared(eraserPos) < eraserRadiusSq ||
          v2.distanceToSquared(eraserPos) < eraserRadiusSq;
        
        // Keep triangle if NOT in sphere
        if (!inSphere) {
          newIndices.push(i0, i1, i2);
        }
      }
      
      // Update geometry with new indices
      geometry.setIndex(newIndices);
      geometry.computeBoundingSphere();
      
      // Update stats
      document.getElementById('stat-tris').textContent = (newIndices.length / 3).toLocaleString();
    }
    
    // Mouse event handlers for eraser
    container.addEventListener('mousemove', (e) => {
      updateEraserPosition(e);
      if (isErasing) {
        eraseAtPosition();
      }
    });
    
    container.addEventListener('mousedown', (e) => {
      if (eraserMode && e.button === 0) {
        isErasing = true;
        eraseAtPosition();
      }
    });
    
    container.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        isErasing = false;
      }
    });
    
    container.addEventListener('mouseleave', () => {
      isErasing = false;
    });
    
    window.togglePoints = function() {
      if (pointsCloud) {
        pointsCloud.visible = document.getElementById('show-points').checked;
      }
    };
    
    window.toggleMesh = function() {
      if (generatedMesh) {
        generatedMesh.visible = document.getElementById('show-mesh').checked;
      }
    };
    
    window.toggleWireframe = function() {
      if (generatedMesh) {
        generatedMesh.material.wireframe = document.getElementById('show-wireframe').checked;
      }
    };
    
    window.generateMesh = generateMesh;
    
    window.exportGLB = async function() {
      if (!generatedMesh) {
        setStatus('No mesh to export. Generate one first.');
        return;
      }
      
      setStatus('Exporting GLB...');
      
      const exportScene = new THREE.Scene();
      const exportMesh = generatedMesh.clone();
      exportMesh.material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      exportScene.add(exportMesh);
      
      const exporter = new GLTFExporter();
      exporter.parse(
        exportScene,
        (gltf) => {
          const blob = new Blob([gltf], { type: 'model/gltf-binary' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'collision-mesh.glb';
          a.click();
          URL.revokeObjectURL(url);
          setStatus('Exported collision-mesh.glb');
        },
        (error) => {
          console.error('Export error:', error);
          setStatus('Export failed: ' + error.message);
        },
        { binary: true }
      );
    };
    
    function setStatus(msg) {
      document.getElementById('status').innerHTML = msg;
    }
    
    function setProgress(percent) {
      document.getElementById('progress').style.width = percent + '%';
    }
    
    // ========== Resize ==========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // SparkControls handles input; we don't manage keys ourselves
    
    // ========== Animation Loop ==========
    let lastTime = performance.now();
    function animate(time) {
      const delta = (time - lastTime) || 16;
      lastTime = time;

      // Scale movement speed via SparkControls' fpsMovement.moveSpeed
      if (controls?.fpsMovement) {
        controls.fpsMovement.moveSpeed = moveSpeedScalar;
      }

      // Update SparkControls
      controls.update(camera);

      // Apply manual yaw from Q/E
      if (keyState.q) {
        camera.rotation.y += yawSpeed * (delta / 16);
      } else if (keyState.e) {
        camera.rotation.y -= yawSpeed * (delta / 16);
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
