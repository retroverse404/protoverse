<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Splat to Collision Mesh</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #1a1a2e; 
      color: #eee;
      overflow: hidden;
    }
    #canvas-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 0;
    }
    canvas { 
      display: block; 
      touch-action: none;
    }
    
    /* Toolbar */
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      bottom: 60px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 100;
      max-width: 280px;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 5px;
    }
    #toolbar::-webkit-scrollbar {
      width: 6px;
    }
    #toolbar::-webkit-scrollbar-track {
      background: rgba(30, 30, 50, 0.5);
      border-radius: 3px;
    }
    #toolbar::-webkit-scrollbar-thumb {
      background: #4a4a6a;
      border-radius: 3px;
    }
    #toolbar::-webkit-scrollbar-thumb:hover {
      background: #6a6a9a;
    }
    .toolbar-group {
      background: rgba(30, 30, 50, 0.95);
      border-radius: 8px;
      padding: 12px;
      border: 1px solid #3a3a5a;
      flex-shrink: 0;
    }
    .toolbar-group h3 {
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 8px;
      letter-spacing: 1px;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .toolbar-group h3::after {
      content: '▼';
      font-size: 8px;
      transition: transform 0.2s;
    }
    .toolbar-group.collapsed h3::after {
      transform: rotate(-90deg);
    }
    .toolbar-group.collapsed .group-content {
      display: none;
    }
    .group-content {
      /* Content wrapper for collapse */
    }
    .btn {
      background: #2a2a4a;
      border: 1px solid #4a4a6a;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      display: block;
      width: 100%;
      margin-bottom: 4px;
    }
    .btn:hover { background: #3a3a6a; border-color: #6a6a9a; }
    .btn:active { background: #4a4a7a; }
    .btn.primary { background: #4a6aaa; border-color: #6a8aca; }
    .btn.primary:hover { background: #5a7aba; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .prop-row {
      margin-bottom: 10px;
    }
    .prop-row label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }
    .prop-row input[type="range"] {
      width: 100%;
    }
    .prop-row .value {
      font-size: 11px;
      color: #6a8aca;
      float: right;
    }
    
    .stats-row {
      font-size: 11px;
      color: #888;
      margin-bottom: 4px;
    }
    .stats-row .label { color: #666; }
    .stats-row .value { color: #6a8aca; }
    
    /* Status bar */
    #status {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(30, 30, 50, 0.9);
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 12px;
      color: #888;
      z-index: 100;
    }
    #status .hint { color: #6a8aca; }
    
    /* Progress */
    .progress-bar {
      height: 4px;
      background: #2a2a4a;
      border-radius: 2px;
      margin-top: 8px;
      overflow: hidden;
    }
    .progress-bar .fill {
      height: 100%;
      background: #4a9aff;
      width: 0%;
      transition: width 0.3s;
    }
    
    /* Toggle */
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .toggle-row label { font-size: 12px; color: #888; }
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="toolbar">
    <div class="toolbar-group">
      <h3 onclick="toggleSection(this)">1. Load File</h3>
      <div class="group-content">
        <button class="btn" onclick="document.getElementById('file-input').click()">Load .spz / .glb file</button>
        <input type="file" id="file-input" accept=".spz,.ply,.splat,.glb,.gltf" style="display:none">
        <div id="splat-stats" style="margin-top: 8px;">
          <div class="stats-row"><span class="label">Splats:</span> <span class="value" id="stat-splats">-</span></div>
        </div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3 onclick="toggleSection(this)">2. Downsample</h3>
      <div class="group-content">
        <div class="prop-row">
          <label>Opacity Cutoff <span class="value" id="opacity-threshold-value">0.05</span></label>
          <input type="range" id="opacity-threshold" min="0" max="1" step="0.01" value="0.05" oninput="updateOpacityThreshold()">
        </div>
        <div class="prop-row">
          <label>Sample Rate <span class="value" id="sample-rate-value">10%</span></label>
          <input type="range" id="sample-rate" min="1" max="100" value="10" oninput="updateSampleRate()">
        </div>
        <div class="stats-row"><span class="label">After opacity:</span> <span class="value" id="stat-filtered">-</span></div>
        <div class="stats-row"><span class="label">Points used:</span> <span class="value" id="stat-points">-</span></div>
      </div>
    </div>

    <div class="toolbar-group collapsed">
      <h3 onclick="toggleSection(this)">2b. Controls</h3>
      <div class="group-content">
        <div class="prop-row">
          <label>Move Speed <span class="value" id="move-speed-value">5.0</span></label>
          <input type="range" id="move-speed" min="0.1" max="5" step="0.1" value="5" oninput="updateMoveSpeed()">
        </div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3 onclick="toggleSection(this)">3. Generate Mesh</h3>
      <div class="group-content">
        <div class="prop-row">
          <label>Voxel Resolution <span class="value" id="voxel-res-value">50</span></label>
          <input type="range" id="voxel-resolution" min="20" max="500" value="50" oninput="updateVoxelRes()">
        </div>
        <div class="prop-row">
          <label>Fill Radius <span class="value" id="fill-radius-value">2.0</span></label>
          <input type="range" id="fill-radius" min="0.1" max="5" value="2" step="0.1" oninput="updateFillRadius()">
        </div>
        <button class="btn primary" id="generate-btn" onclick="generateMesh()" disabled>Generate Mesh</button>
        <div class="progress-bar"><div class="fill" id="progress"></div></div>
        <div class="stats-row" style="margin-top: 8px;"><span class="label">Vertices:</span> <span class="value" id="stat-verts">-</span></div>
        <div class="stats-row"><span class="label">Triangles:</span> <span class="value" id="stat-tris">-</span></div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3 onclick="toggleSection(this)">4. Preview</h3>
      <div class="group-content">
        <div class="toggle-row">
          <input type="checkbox" id="show-points" checked onchange="togglePoints()">
          <label for="show-points">Show sample points</label>
        </div>
        <div class="toggle-row">
          <input type="checkbox" id="show-mesh" checked onchange="toggleMesh()">
          <label for="show-mesh">Show mesh</label>
        </div>
        <div class="toggle-row">
          <input type="checkbox" id="show-wireframe" onchange="toggleWireframe()">
          <label for="show-wireframe">Wireframe mode</label>
        </div>
        <div class="toggle-row">
          <input type="checkbox" id="show-edges" onchange="toggleEdges()">
          <label for="show-edges">Show edges overlay</label>
        </div>
        <div class="toggle-row">
          <input type="checkbox" id="show-vertices" onchange="toggleVertices()">
          <label for="show-vertices">Show vertices</label>
        </div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3 onclick="toggleSection(this)">5. Erase Tool</h3>
      <div class="group-content">
        <div class="toggle-row">
          <input type="checkbox" id="erase-mode" onchange="toggleEraseMode()">
          <label for="erase-mode">Enable Erase Mode</label>
        </div>
        <div class="prop-row">
          <label>Eraser Size <span class="value" id="eraser-size-value">0.1</span></label>
          <input type="range" id="eraser-size" min="0.01" max="0.3" step="0.01" value="0.1" oninput="updateEraserSize()">
        </div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3 onclick="toggleSection(this)">5b. Patch Tool</h3>
      <div class="group-content">
        <div class="toggle-row">
          <input type="checkbox" id="patch-mode" onchange="togglePatchMode()">
          <label for="patch-mode">Enable Patch Mode</label>
        </div>
        <div class="prop-row">
          <label>Patch Size <span class="value" id="patch-size-value">0.2</span></label>
          <input type="range" id="patch-size" min="0.05" max="1" step="0.01" value="0.2" oninput="updatePatchSize()">
        </div>
        <div class="prop-row">
          <label>Rotate X <span class="value" id="patch-rot-x-value">0°</span></label>
          <input type="range" id="patch-rot-x" min="-180" max="180" step="5" value="0" oninput="updatePatchRotation()">
        </div>
        <div class="prop-row">
          <label>Rotate Y <span class="value" id="patch-rot-y-value">0°</span></label>
          <input type="range" id="patch-rot-y" min="-180" max="180" step="5" value="0" oninput="updatePatchRotation()">
        </div>
        <div class="prop-row">
          <label>Rotate Z <span class="value" id="patch-rot-z-value">0°</span></label>
          <input type="range" id="patch-rot-z" min="-180" max="180" step="5" value="0" oninput="updatePatchRotation()">
        </div>
        <div class="prop-row">
          <label>Distance <span class="value" id="patch-distance-value">0.25</span></label>
          <input type="range" id="patch-distance" min="0" max="1" step="0.005" value="0.25" oninput="updatePatchDistance()">
        </div>
        <button class="btn" onclick="resetPatchRotation()">Reset Rotation</button>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3 onclick="toggleSection(this)">6. Export</h3>
      <div class="group-content">
        <button class="btn primary" id="export-btn" onclick="exportGLB()" disabled>Export .glb</button>
      </div>
    </div>
  </div>
  
  <div id="status">
    <span class="hint">Controls:</span> SparkControls (click/drag + WASD). Drop .spz for splat→mesh conversion, or .glb for mesh editing.
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
      "@sparkjsdev/spark": "../lib/spark.module.js"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { SplatMesh, SparkControls } from '@sparkjsdev/spark';
    
    // ========== Scene Setup ==========
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 10000);
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    
    // SparkControls (FPS-like) controlling a localFrame
    const localFrame = new THREE.Group();
    scene.add(localFrame);
    localFrame.add(camera);
    localFrame.position.set(5, 5, 5);

    let moveSpeedScalar = 5.0;

    const controls = new SparkControls({
      renderer,
      canvas: renderer.domElement,
    });

    // Optional yaw with Q/E keys
    const keyState = { q: false, e: false, i: false, j: false, k: false, l: false, u: false, o: false, y: false, h: false };
    const yawSpeed = 0.02; // radians per frame baseline
    const patchRotSpeed = 3; // degrees per frame for patch rotation

    document.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k in keyState) keyState[k] = true;
    });
    document.addEventListener('keyup', (e) => {
      const k = e.key.toLowerCase();
      if (k in keyState) keyState[k] = false;
    });
    
    // Grid helper
    const grid = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
    scene.add(grid);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    
    // ========== State ==========
    let allSplats = []; // { pos: Vector3, alpha: number }
    let sampledPositions = []; // Downsampled positions (Vector3)
    let pointsCloud = null; // THREE.Points for visualization
    let generatedMesh = null; // Generated collision mesh
    let edgesHelper = null; // EdgesHelper for edge overlay
    let verticesCloud = null; // Points for vertex visualization
    
    // ========== Eraser State ==========
    let eraserMode = false;
    let eraserSize = 0.1;
    let eraserSphere = null;
    let isErasing = false;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // ========== Patch Tool State ==========
    let patchMode = false;
    let patchSize = 0.2;
    let patchRotX = 0;
    let patchRotY = 0;
    let patchRotZ = 0;
    let patchDistance = 0.25;
    let patchPlane = null;
    
    // Create eraser sphere (initially hidden)
    const eraserGeometry = new THREE.SphereGeometry(1, 16, 16);
    const eraserMaterial = new THREE.MeshBasicMaterial({
      color: 0xff4444,
      transparent: true,
      opacity: 0.3,
      depthTest: true,
      depthWrite: false
    });
    eraserSphere = new THREE.Mesh(eraserGeometry, eraserMaterial);
    eraserSphere.visible = false;
    eraserSphere.scale.setScalar(eraserSize); // Set initial size
    scene.add(eraserSphere);
    
    // Add wireframe outline to eraser sphere for better visibility
    const eraserWireframe = new THREE.LineSegments(
      new THREE.WireframeGeometry(eraserGeometry),
      new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 0.8, transparent: true })
    );
    eraserSphere.add(eraserWireframe);
    
    // Create patch plane (initially hidden)
    const patchGeometry = new THREE.PlaneGeometry(1, 1);
    const patchMaterial = new THREE.MeshBasicMaterial({
      color: 0x44ff44,
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide,
      depthTest: true,
      depthWrite: false
    });
    patchPlane = new THREE.Mesh(patchGeometry, patchMaterial);
    patchPlane.visible = false;
    patchPlane.scale.setScalar(patchSize);
    scene.add(patchPlane);
    
    // Add wireframe outline to patch plane
    const patchEdges = new THREE.EdgesGeometry(patchGeometry);
    const patchWireframe = new THREE.LineSegments(
      patchEdges,
      new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 })
    );
    patchPlane.add(patchWireframe);
    
    // Add normal indicator arrow to show which way the patch faces
    const arrowLength = 0.5;
    const arrowGeometry = new THREE.BufferGeometry();
    arrowGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
      0, 0, 0,
      0, 0, arrowLength,
      0, 0, arrowLength,
      0.05, 0, arrowLength - 0.1,
      0, 0, arrowLength,
      -0.05, 0, arrowLength - 0.1
    ], 3));
    const arrowMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
    const normalArrow = new THREE.LineSegments(arrowGeometry, arrowMaterial);
    patchPlane.add(normalArrow);
    
    // ========== File Loading ==========
    const fileInput = document.getElementById('file-input');
    
    // Drag and drop on document
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const file = e.dataTransfer.files[0];
      if (file) {
        if (file.name.endsWith('.glb') || file.name.endsWith('.gltf')) {
          await loadGLBFile(file);
        } else if (file.name.endsWith('.spz') || file.name.endsWith('.ply') || file.name.endsWith('.splat')) {
          await loadSplatFile(file);
        }
      }
    });
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        if (file.name.endsWith('.glb') || file.name.endsWith('.gltf')) {
          await loadGLBFile(file);
        } else {
          await loadSplatFile(file);
        }
      }
    });
    
    async function loadSplatFile(file) {
      try {
        setStatus('Loading splat file...');
        console.log('Loading:', file.name, file.size, 'bytes');
        
        const arrayBuffer = await file.arrayBuffer();
        const fileBytes = new Uint8Array(arrayBuffer);
        
        // Create SplatMesh to parse the file
        const splatMesh = new SplatMesh({
          fileBytes,
          fileName: file.name
        });
        
        await splatMesh.initialized;
        
        // Wait a frame for data to be ready
        await new Promise(resolve => requestAnimationFrame(resolve));
        
        const packedSplats = splatMesh.packedSplats;
        const numSplats = packedSplats?.numSplats || 0;
        
        console.log('Loaded', numSplats, 'splats');
        document.getElementById('stat-splats').textContent = numSplats.toLocaleString();
        
        if (numSplats === 0) {
          setStatus('Error: No splats found in file');
          return;
        }
        
        // Extract all splat positions + opacity
        allSplats = [];
        for (let i = 0; i < numSplats; i++) {
          const splat = packedSplats.getSplat(i);
          const pos = splat.center;
          if (pos && isFinite(pos.x) && isFinite(pos.y) && isFinite(pos.z)) {
            // Spark splats carry opacity; fall back to rgba.a if needed
            const opacity = splat.opacity ?? splat.rgba?.a ?? 1;
            allSplats.push({ pos: new THREE.Vector3(pos.x, pos.y, pos.z), alpha: opacity });
          }
        }
        
        console.log('Extracted', allSplats.length, 'valid positions');
        
        // Dispose the SplatMesh - we only needed the positions
        splatMesh.dispose();
        
        // Update sample and center camera
        updateSampledPositions();
        centerCameraOnPoints();
        
        // Enable generate button
        document.getElementById('generate-btn').disabled = false;
        
        setStatus(`Loaded ${numSplats.toLocaleString()} splats. Adjust sampling and generate mesh.`);
        
      } catch (err) {
        console.error('Error loading splat:', err);
        setStatus('Error: ' + err.message);
      }
    }
    
    // ========== GLB Loading ==========
    async function loadGLBFile(file) {
      try {
        setStatus('Loading GLB file...');
        console.log('Loading GLB:', file.name, file.size, 'bytes');
        
        const arrayBuffer = await file.arrayBuffer();
        const loader = new GLTFLoader();
        
        // Parse the GLB from array buffer
        const gltf = await new Promise((resolve, reject) => {
          loader.parse(arrayBuffer, '', resolve, reject);
        });
        
        console.log('GLB loaded:', gltf);
        
        // Remove existing mesh if any
        if (generatedMesh) {
          scene.remove(generatedMesh);
          generatedMesh.geometry.dispose();
          generatedMesh.material.dispose();
          generatedMesh = null;
        }
        
        // Find the first mesh in the loaded scene
        let foundMesh = null;
        gltf.scene.traverse((child) => {
          if (!foundMesh && child.isMesh) {
            foundMesh = child;
          }
        });
        
        if (!foundMesh) {
          setStatus('Error: No mesh found in GLB file');
          return;
        }
        
        // Clone the geometry and create a new mesh with our material
        const geometry = foundMesh.geometry.clone();
        
        // Make sure we have an index buffer for the eraser tool
        if (!geometry.index) {
          // Convert to indexed geometry
          const positions = geometry.getAttribute('position');
          const indices = [];
          for (let i = 0; i < positions.count; i++) {
            indices.push(i);
          }
          geometry.setIndex(indices);
        }
        
        const material = new THREE.MeshStandardMaterial({
          color: 0x88aaff,
          side: THREE.DoubleSide,
          wireframe: document.getElementById('show-wireframe').checked
        });
        
        generatedMesh = new THREE.Mesh(geometry, material);
        
        // Apply the world transform from the original mesh
        foundMesh.updateWorldMatrix(true, false);
        generatedMesh.applyMatrix4(foundMesh.matrixWorld);
        
        generatedMesh.visible = document.getElementById('show-mesh').checked;
        scene.add(generatedMesh);
        
        // Update helpers (edges/vertices overlays)
        updateMeshHelpers();
        
        // Update stats
        const vertCount = geometry.getAttribute('position').count;
        const triCount = geometry.index ? geometry.index.count / 3 : vertCount / 3;
        document.getElementById('stat-verts').textContent = vertCount.toLocaleString();
        document.getElementById('stat-tris').textContent = Math.floor(triCount).toLocaleString();
        
        // Enable export
        document.getElementById('export-btn').disabled = false;
        
        // Center camera on the loaded mesh
        const bounds = new THREE.Box3().setFromObject(generatedMesh);
        const center = bounds.getCenter(new THREE.Vector3());
        const size = bounds.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z) || 10;
        
        localFrame.position.set(
          center.x + maxDim * 0.8,
          center.y + maxDim * 0.5,
          center.z + maxDim * 0.8
        );
        
        setStatus(`Loaded GLB with ${vertCount.toLocaleString()} vertices, ${Math.floor(triCount).toLocaleString()} triangles. Use erase tool to edit.`);
        
      } catch (err) {
        console.error('Error loading GLB:', err);
        setStatus('Error: ' + err.message);
      }
    }
    
    // ========== Sampling ==========
    function updateSampledPositions() {
      const sampleRate = parseInt(document.getElementById('sample-rate').value) / 100;
      const opacityThreshold = parseFloat(document.getElementById('opacity-threshold').value);

      // Filter by opacity
      const filtered = allSplats.filter(s => s.alpha >= opacityThreshold);
      document.getElementById('stat-filtered').textContent = filtered.length.toLocaleString();

      const numSamples = Math.max(1, Math.floor(filtered.length * sampleRate));
      
      // Uniform step sampling
      sampledPositions = [];
      const step = Math.max(1, Math.floor(filtered.length / numSamples));
      
      for (let i = 0; i < filtered.length; i += step) {
        sampledPositions.push(filtered[i].pos);
      }
      
      document.getElementById('stat-points').textContent = sampledPositions.length.toLocaleString();
      
      // Update point cloud visualization
      updatePointCloud();
    }
    
    function updatePointCloud() {
      if (pointsCloud) {
        scene.remove(pointsCloud);
        pointsCloud.geometry.dispose();
        pointsCloud.material.dispose();
      }
      
      if (sampledPositions.length === 0) return;
      
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(sampledPositions.length * 3);
      
      for (let i = 0; i < sampledPositions.length; i++) {
        positions[i * 3] = sampledPositions[i].x;
        positions[i * 3 + 1] = sampledPositions[i].y;
        positions[i * 3 + 2] = sampledPositions[i].z;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const material = new THREE.PointsMaterial({
        color: 0x4a9aff,
        size: 0.02,
        sizeAttenuation: true
      });
      
      pointsCloud = new THREE.Points(geometry, material);
      pointsCloud.visible = document.getElementById('show-points').checked;
      scene.add(pointsCloud);
    }
    
    function centerCameraOnPoints() {
      if (sampledPositions.length === 0) return;
      
      const bounds = new THREE.Box3();
      for (const pos of sampledPositions) {
        bounds.expandByPoint(pos);
      }
      
      const center = bounds.getCenter(new THREE.Vector3());
      const size = bounds.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 10;
      
      localFrame.position.set(
        center.x + maxDim * 0.8,
        center.y + maxDim * 0.5,
        center.z + maxDim * 0.8
      );
      // Face the center
      //localFrame.lookAt(center);
    }
    
    // ========== Mesh Generation (Marching Cubes) ==========
    async function generateMesh() {
      if (sampledPositions.length === 0) {
        setStatus('No points to process. Load a splat file first.');
        return;
      }
      
      setStatus('Generating mesh...');
      setProgress(0);
      
      // Allow UI to update
      await new Promise(resolve => setTimeout(resolve, 50));
      
      const resolution = parseInt(document.getElementById('voxel-resolution').value);
      const fillRadius = parseFloat(document.getElementById('fill-radius').value);
      
      try {
        // Step 1: Compute bounds
        const bounds = new THREE.Box3();
        for (const pos of sampledPositions) {
          bounds.expandByPoint(pos);
        }
        bounds.expandByScalar(0.5); // Padding
        
        const size = bounds.getSize(new THREE.Vector3());
        const maxSize = Math.max(size.x, size.y, size.z);
        const voxelSize = maxSize / resolution;
        
        const nx = Math.ceil(size.x / voxelSize) + 2;
        const ny = Math.ceil(size.y / voxelSize) + 2;
        const nz = Math.ceil(size.z / voxelSize) + 2;
        
        console.log('Voxel grid:', nx, 'x', ny, 'x', nz);
        setProgress(10);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Step 2: Create voxel grid (density field)
        const voxels = new Float32Array(nx * ny * nz);
        
        // Fill voxels based on point positions
        const fillRadiusInt = Math.ceil(fillRadius);
        
        for (let i = 0; i < sampledPositions.length; i++) {
          const pos = sampledPositions[i];
          
          // Convert to voxel coordinates (can be fractional)
          const vxf = (pos.x - bounds.min.x) / voxelSize;
          const vyf = (pos.y - bounds.min.y) / voxelSize;
          const vzf = (pos.z - bounds.min.z) / voxelSize;
          
          const vx = Math.floor(vxf);
          const vy = Math.floor(vyf);
          const vz = Math.floor(vzf);
          
          // Fill neighboring cells with falloff
          for (let dx = -fillRadiusInt; dx <= fillRadiusInt; dx++) {
            for (let dy = -fillRadiusInt; dy <= fillRadiusInt; dy++) {
              for (let dz = -fillRadiusInt; dz <= fillRadiusInt; dz++) {
                const ix = vx + dx;
                const iy = vy + dy;
                const iz = vz + dz;
                
                if (ix >= 0 && ix < nx && iy >= 0 && iy < ny && iz >= 0 && iz < nz) {
                  // Calculate actual distance from the point (in voxel units)
                  const actualDx = ix - vxf + 0.5; // Distance to voxel center
                  const actualDy = iy - vyf + 0.5;
                  const actualDz = iz - vzf + 0.5;
                  const dist = Math.sqrt(actualDx*actualDx + actualDy*actualDy + actualDz*actualDz);
                  
                  // Smooth falloff based on fill radius
                  const weight = Math.max(0, 1 - dist / (fillRadius + 0.5));
                  const idx = ix + iy * nx + iz * nx * ny;
                  voxels[idx] = Math.max(voxels[idx], weight);
                }
              }
            }
          }
          
          // Update progress occasionally
          if (i % 10000 === 0) {
            setProgress(10 + (i / sampledPositions.length) * 30);
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }
        
        setProgress(40);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Step 3: Marching cubes
        console.log('Running marching cubes...');
        const { vertices, indices } = marchingCubes(voxels, nx, ny, nz, bounds, voxelSize, 0.5);
        
        setProgress(80);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        if (vertices.length === 0) {
          setStatus('No mesh generated. Try increasing fill radius or sample rate.');
          setProgress(0);
          return;
        }
        
        // Step 4: Create mesh
        if (generatedMesh) {
          scene.remove(generatedMesh);
          generatedMesh.geometry.dispose();
          generatedMesh.material.dispose();
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshStandardMaterial({
          color: 0x88aaff,
          side: THREE.DoubleSide,
          wireframe: document.getElementById('show-wireframe').checked
        });
        
        generatedMesh = new THREE.Mesh(geometry, material);
        generatedMesh.visible = document.getElementById('show-mesh').checked;
        scene.add(generatedMesh);
        
        // Update helpers (edges/vertices overlays)
        updateMeshHelpers();
        
        // Update stats
        document.getElementById('stat-verts').textContent = (vertices.length / 3).toLocaleString();
        document.getElementById('stat-tris').textContent = (indices.length / 3).toLocaleString();
        
        // Enable export
        document.getElementById('export-btn').disabled = false;
        
        setProgress(100);
        setStatus(`Generated mesh with ${(vertices.length/3).toLocaleString()} vertices, ${(indices.length/3).toLocaleString()} triangles`);
        
        setTimeout(() => setProgress(0), 1000);
        
      } catch (err) {
        console.error('Error generating mesh:', err);
        setStatus('Error: ' + err.message);
        setProgress(0);
      }
    }
    
    // ========== Marching Cubes Implementation ==========
    function marchingCubes(voxels, nx, ny, nz, bounds, voxelSize, isoLevel) {
      const vertices = [];
      const indices = [];
      const vertexMap = new Map(); // For vertex deduplication
      
      function getVoxel(ix, iy, iz) {
        if (ix < 0 || ix >= nx || iy < 0 || iy >= ny || iz < 0 || iz >= nz) return 0;
        return voxels[ix + iy * nx + iz * nx * ny];
      }
      
      function getPosition(ix, iy, iz) {
        return new THREE.Vector3(
          bounds.min.x + ix * voxelSize,
          bounds.min.y + iy * voxelSize,
          bounds.min.z + iz * voxelSize
        );
      }
      
      function interpolateVertex(p1, p2, v1, v2) {
        if (Math.abs(isoLevel - v1) < 0.00001) return p1.clone();
        if (Math.abs(isoLevel - v2) < 0.00001) return p2.clone();
        if (Math.abs(v1 - v2) < 0.00001) return p1.clone();
        const t = (isoLevel - v1) / (v2 - v1);
        return new THREE.Vector3().lerpVectors(p1, p2, t);
      }
      
      function addVertex(v) {
        const key = `${v.x.toFixed(5)},${v.y.toFixed(5)},${v.z.toFixed(5)}`;
        if (vertexMap.has(key)) {
          return vertexMap.get(key);
        }
        const idx = vertices.length / 3;
        vertices.push(v.x, v.y, v.z);
        vertexMap.set(key, idx);
        return idx;
      }
      
      // Process each voxel cell
      // Standard marching cubes vertex ordering (Paul Bourke convention):
      //        4-----------5
      //       /|          /|
      //      / |         / |
      //     /  |        /  |
      //    7-----------6   |
      //    |   |       |   |
      //    |   0-------|---1
      //    |  /        |  /
      //    | /         | /
      //    |/          |/
      //    3-----------2
      // 
      // Vertex positions: 0:(0,0,0), 1:(1,0,0), 2:(1,0,1), 3:(0,0,1)
      //                   4:(0,1,0), 5:(1,1,0), 6:(1,1,1), 7:(0,1,1)
      
      for (let iz = 0; iz < nz - 1; iz++) {
        for (let iy = 0; iy < ny - 1; iy++) {
          for (let ix = 0; ix < nx - 1; ix++) {
            // Get 8 corner values - using standard marching cubes vertex ordering
            const v = [
              getVoxel(ix, iy, iz),           // 0: (0,0,0)
              getVoxel(ix + 1, iy, iz),       // 1: (1,0,0)
              getVoxel(ix + 1, iy, iz + 1),   // 2: (1,0,1)
              getVoxel(ix, iy, iz + 1),       // 3: (0,0,1)
              getVoxel(ix, iy + 1, iz),       // 4: (0,1,0)
              getVoxel(ix + 1, iy + 1, iz),   // 5: (1,1,0)
              getVoxel(ix + 1, iy + 1, iz + 1), // 6: (1,1,1)
              getVoxel(ix, iy + 1, iz + 1)    // 7: (0,1,1)
            ];
            
            // Calculate cube index
            let cubeIndex = 0;
            for (let i = 0; i < 8; i++) {
              if (v[i] > isoLevel) cubeIndex |= (1 << i);
            }
            
            // Skip empty or full cubes
            if (cubeIndex === 0 || cubeIndex === 255) continue;
            
            // Get corner positions - matching vertex ordering above
            const p = [
              getPosition(ix, iy, iz),           // 0
              getPosition(ix + 1, iy, iz),       // 1
              getPosition(ix + 1, iy, iz + 1),   // 2
              getPosition(ix, iy, iz + 1),       // 3
              getPosition(ix, iy + 1, iz),       // 4
              getPosition(ix + 1, iy + 1, iz),   // 5
              getPosition(ix + 1, iy + 1, iz + 1), // 6
              getPosition(ix, iy + 1, iz + 1)    // 7
            ];
            
            // Edge table - which edges are crossed
            const edges = EDGE_TABLE[cubeIndex];
            if (edges === 0) continue;
            
            // Interpolate vertices on edges
            const edgeVertices = new Array(12);
            
            if (edges & 1) edgeVertices[0] = interpolateVertex(p[0], p[1], v[0], v[1]);
            if (edges & 2) edgeVertices[1] = interpolateVertex(p[1], p[2], v[1], v[2]);
            if (edges & 4) edgeVertices[2] = interpolateVertex(p[2], p[3], v[2], v[3]);
            if (edges & 8) edgeVertices[3] = interpolateVertex(p[3], p[0], v[3], v[0]);
            if (edges & 16) edgeVertices[4] = interpolateVertex(p[4], p[5], v[4], v[5]);
            if (edges & 32) edgeVertices[5] = interpolateVertex(p[5], p[6], v[5], v[6]);
            if (edges & 64) edgeVertices[6] = interpolateVertex(p[6], p[7], v[6], v[7]);
            if (edges & 128) edgeVertices[7] = interpolateVertex(p[7], p[4], v[7], v[4]);
            if (edges & 256) edgeVertices[8] = interpolateVertex(p[0], p[4], v[0], v[4]);
            if (edges & 512) edgeVertices[9] = interpolateVertex(p[1], p[5], v[1], v[5]);
            if (edges & 1024) edgeVertices[10] = interpolateVertex(p[2], p[6], v[2], v[6]);
            if (edges & 2048) edgeVertices[11] = interpolateVertex(p[3], p[7], v[3], v[7]);
            
            // Create triangles from tri table
            const triData = TRI_TABLE[cubeIndex];
            for (let i = 0; triData[i] !== -1; i += 3) {
              const v0 = edgeVertices[triData[i]];
              const v1 = edgeVertices[triData[i + 1]];
              const v2 = edgeVertices[triData[i + 2]];
              
              if (v0 && v1 && v2) {
                const i0 = addVertex(v0);
                const i1 = addVertex(v1);
                const i2 = addVertex(v2);
                indices.push(i0, i1, i2);
              }
            }
          }
        }
      }
      
      return { vertices, indices };
    }
    
    // Marching cubes lookup tables (standard tables)
    const EDGE_TABLE = [
      0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
      0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
      0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
      0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
      0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
      0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
      0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
      0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
      0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
      0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
      0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
      0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
      0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
      0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
      0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
      0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
    ];
    
    // Triangle table - for each cube configuration, list of edge indices forming triangles
    // -1 terminates each configuration
    const TRI_TABLE = [
      [-1],
      [0, 8, 3, -1],
      [0, 1, 9, -1],
      [1, 8, 3, 9, 8, 1, -1],
      [1, 2, 10, -1],
      [0, 8, 3, 1, 2, 10, -1],
      [9, 2, 10, 0, 2, 9, -1],
      [2, 8, 3, 2, 10, 8, 10, 9, 8, -1],
      [3, 11, 2, -1],
      [0, 11, 2, 8, 11, 0, -1],
      [1, 9, 0, 2, 3, 11, -1],
      [1, 11, 2, 1, 9, 11, 9, 8, 11, -1],
      [3, 10, 1, 11, 10, 3, -1],
      [0, 10, 1, 0, 8, 10, 8, 11, 10, -1],
      [3, 9, 0, 3, 11, 9, 11, 10, 9, -1],
      [9, 8, 10, 10, 8, 11, -1],
      [4, 7, 8, -1],
      [4, 3, 0, 7, 3, 4, -1],
      [0, 1, 9, 8, 4, 7, -1],
      [4, 1, 9, 4, 7, 1, 7, 3, 1, -1],
      [1, 2, 10, 8, 4, 7, -1],
      [3, 4, 7, 3, 0, 4, 1, 2, 10, -1],
      [9, 2, 10, 9, 0, 2, 8, 4, 7, -1],
      [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1],
      [8, 4, 7, 3, 11, 2, -1],
      [11, 4, 7, 11, 2, 4, 2, 0, 4, -1],
      [9, 0, 1, 8, 4, 7, 2, 3, 11, -1],
      [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1],
      [3, 10, 1, 3, 11, 10, 7, 8, 4, -1],
      [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1],
      [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1],
      [4, 7, 11, 4, 11, 9, 9, 11, 10, -1],
      [9, 5, 4, -1],
      [9, 5, 4, 0, 8, 3, -1],
      [0, 5, 4, 1, 5, 0, -1],
      [8, 5, 4, 8, 3, 5, 3, 1, 5, -1],
      [1, 2, 10, 9, 5, 4, -1],
      [3, 0, 8, 1, 2, 10, 4, 9, 5, -1],
      [5, 2, 10, 5, 4, 2, 4, 0, 2, -1],
      [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1],
      [9, 5, 4, 2, 3, 11, -1],
      [0, 11, 2, 0, 8, 11, 4, 9, 5, -1],
      [0, 5, 4, 0, 1, 5, 2, 3, 11, -1],
      [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1],
      [10, 3, 11, 10, 1, 3, 9, 5, 4, -1],
      [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1],
      [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1],
      [5, 4, 8, 5, 8, 10, 10, 8, 11, -1],
      [9, 7, 8, 5, 7, 9, -1],
      [9, 3, 0, 9, 5, 3, 5, 7, 3, -1],
      [0, 7, 8, 0, 1, 7, 1, 5, 7, -1],
      [1, 5, 3, 3, 5, 7, -1],
      [9, 7, 8, 9, 5, 7, 10, 1, 2, -1],
      [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1],
      [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1],
      [2, 10, 5, 2, 5, 3, 3, 5, 7, -1],
      [7, 9, 5, 7, 8, 9, 3, 11, 2, -1],
      [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1],
      [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1],
      [11, 2, 1, 11, 1, 7, 7, 1, 5, -1],
      [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1],
      [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
      [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
      [11, 10, 5, 7, 11, 5, -1],
      [10, 6, 5, -1],
      [0, 8, 3, 5, 10, 6, -1],
      [9, 0, 1, 5, 10, 6, -1],
      [1, 8, 3, 1, 9, 8, 5, 10, 6, -1],
      [1, 6, 5, 2, 6, 1, -1],
      [1, 6, 5, 1, 2, 6, 3, 0, 8, -1],
      [9, 6, 5, 9, 0, 6, 0, 2, 6, -1],
      [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1],
      [2, 3, 11, 10, 6, 5, -1],
      [11, 0, 8, 11, 2, 0, 10, 6, 5, -1],
      [0, 1, 9, 2, 3, 11, 5, 10, 6, -1],
      [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1],
      [6, 3, 11, 6, 5, 3, 5, 1, 3, -1],
      [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1],
      [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1],
      [6, 5, 9, 6, 9, 11, 11, 9, 8, -1],
      [5, 10, 6, 4, 7, 8, -1],
      [4, 3, 0, 4, 7, 3, 6, 5, 10, -1],
      [1, 9, 0, 5, 10, 6, 8, 4, 7, -1],
      [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1],
      [6, 1, 2, 6, 5, 1, 4, 7, 8, -1],
      [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1],
      [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1],
      [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
      [3, 11, 2, 7, 8, 4, 10, 6, 5, -1],
      [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1],
      [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1],
      [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
      [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1],
      [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
      [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
      [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1],
      [10, 4, 9, 6, 4, 10, -1],
      [4, 10, 6, 4, 9, 10, 0, 8, 3, -1],
      [10, 0, 1, 10, 6, 0, 6, 4, 0, -1],
      [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1],
      [1, 4, 9, 1, 2, 4, 2, 6, 4, -1],
      [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1],
      [0, 2, 4, 4, 2, 6, -1],
      [8, 3, 2, 8, 2, 4, 4, 2, 6, -1],
      [10, 4, 9, 10, 6, 4, 11, 2, 3, -1],
      [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1],
      [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1],
      [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
      [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1],
      [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
      [3, 11, 6, 3, 6, 0, 0, 6, 4, -1],
      [6, 4, 8, 11, 6, 8, -1],
      [7, 10, 6, 7, 8, 10, 8, 9, 10, -1],
      [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1],
      [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1],
      [10, 6, 7, 10, 7, 1, 1, 7, 3, -1],
      [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1],
      [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
      [7, 8, 0, 7, 0, 6, 6, 0, 2, -1],
      [7, 3, 2, 6, 7, 2, -1],
      [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1],
      [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
      [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
      [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1],
      [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
      [0, 9, 1, 11, 6, 7, -1],
      [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1],
      [7, 11, 6, -1],
      [7, 6, 11, -1],
      [3, 0, 8, 11, 7, 6, -1],
      [0, 1, 9, 11, 7, 6, -1],
      [8, 1, 9, 8, 3, 1, 11, 7, 6, -1],
      [10, 1, 2, 6, 11, 7, -1],
      [1, 2, 10, 3, 0, 8, 6, 11, 7, -1],
      [2, 9, 0, 2, 10, 9, 6, 11, 7, -1],
      [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1],
      [7, 2, 3, 6, 2, 7, -1],
      [7, 0, 8, 7, 6, 0, 6, 2, 0, -1],
      [2, 7, 6, 2, 3, 7, 0, 1, 9, -1],
      [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1],
      [10, 7, 6, 10, 1, 7, 1, 3, 7, -1],
      [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1],
      [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1],
      [7, 6, 10, 7, 10, 8, 8, 10, 9, -1],
      [6, 8, 4, 11, 8, 6, -1],
      [3, 6, 11, 3, 0, 6, 0, 4, 6, -1],
      [8, 6, 11, 8, 4, 6, 9, 0, 1, -1],
      [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1],
      [6, 8, 4, 6, 11, 8, 2, 10, 1, -1],
      [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1],
      [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1],
      [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
      [8, 2, 3, 8, 4, 2, 4, 6, 2, -1],
      [0, 4, 2, 4, 6, 2, -1],
      [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1],
      [1, 9, 4, 1, 4, 2, 2, 4, 6, -1],
      [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1],
      [10, 1, 0, 10, 0, 6, 6, 0, 4, -1],
      [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
      [10, 9, 4, 6, 10, 4, -1],
      [4, 9, 5, 7, 6, 11, -1],
      [0, 8, 3, 4, 9, 5, 11, 7, 6, -1],
      [5, 0, 1, 5, 4, 0, 7, 6, 11, -1],
      [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1],
      [9, 5, 4, 10, 1, 2, 7, 6, 11, -1],
      [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1],
      [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1],
      [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
      [7, 2, 3, 7, 6, 2, 5, 4, 9, -1],
      [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1],
      [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1],
      [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
      [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1],
      [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
      [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
      [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1],
      [6, 9, 5, 6, 11, 9, 11, 8, 9, -1],
      [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1],
      [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1],
      [6, 11, 3, 6, 3, 5, 5, 3, 1, -1],
      [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1],
      [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
      [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
      [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1],
      [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1],
      [9, 5, 6, 9, 6, 0, 0, 6, 2, -1],
      [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
      [1, 5, 6, 2, 1, 6, -1],
      [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
      [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1],
      [0, 3, 8, 5, 6, 10, -1],
      [10, 5, 6, -1],
      [11, 5, 10, 7, 5, 11, -1],
      [11, 5, 10, 11, 7, 5, 8, 3, 0, -1],
      [5, 11, 7, 5, 10, 11, 1, 9, 0, -1],
      [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1],
      [11, 1, 2, 11, 7, 1, 7, 5, 1, -1],
      [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1],
      [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1],
      [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
      [2, 5, 10, 2, 3, 5, 3, 7, 5, -1],
      [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1],
      [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1],
      [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
      [1, 3, 5, 3, 7, 5, -1],
      [0, 8, 7, 0, 7, 1, 1, 7, 5, -1],
      [9, 0, 3, 9, 3, 5, 5, 3, 7, -1],
      [9, 8, 7, 5, 9, 7, -1],
      [5, 8, 4, 5, 10, 8, 10, 11, 8, -1],
      [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1],
      [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1],
      [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
      [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1],
      [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
      [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
      [9, 4, 5, 2, 11, 3, -1],
      [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1],
      [5, 10, 2, 5, 2, 4, 4, 2, 0, -1],
      [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
      [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1],
      [8, 4, 5, 8, 5, 3, 3, 5, 1, -1],
      [0, 4, 5, 1, 0, 5, -1],
      [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1],
      [9, 4, 5, -1],
      [4, 11, 7, 4, 9, 11, 9, 10, 11, -1],
      [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1],
      [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1],
      [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
      [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1],
      [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
      [11, 7, 4, 11, 4, 2, 2, 4, 0, -1],
      [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1],
      [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1],
      [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
      [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
      [1, 10, 2, 8, 7, 4, -1],
      [4, 9, 1, 4, 1, 7, 7, 1, 3, -1],
      [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1],
      [4, 0, 3, 7, 4, 3, -1],
      [4, 8, 7, -1],
      [9, 10, 8, 10, 11, 8, -1],
      [3, 0, 9, 3, 9, 11, 11, 9, 10, -1],
      [0, 1, 10, 0, 10, 8, 8, 10, 11, -1],
      [3, 1, 10, 11, 3, 10, -1],
      [1, 2, 11, 1, 11, 9, 9, 11, 8, -1],
      [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1],
      [0, 2, 11, 8, 0, 11, -1],
      [3, 2, 11, -1],
      [2, 3, 8, 2, 8, 10, 10, 8, 9, -1],
      [9, 10, 2, 0, 9, 2, -1],
      [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1],
      [1, 10, 2, -1],
      [1, 3, 8, 9, 1, 8, -1],
      [0, 9, 1, -1],
      [0, 3, 8, -1],
      [-1]
    ];
    
    // ========== UI Functions ==========
    window.toggleSection = function(header) {
      const group = header.parentElement;
      group.classList.toggle('collapsed');
    };
    
    window.updateSampleRate = function() {
      const val = document.getElementById('sample-rate').value;
      document.getElementById('sample-rate-value').textContent = val + '%';
      updateSampledPositions();
    };

    window.updateOpacityThreshold = function() {
      const val = document.getElementById('opacity-threshold').value;
      document.getElementById('opacity-threshold-value').textContent = parseFloat(val).toFixed(2);
      updateSampledPositions();
    };

    window.updateMoveSpeed = function() {
      const val = parseFloat(document.getElementById('move-speed').value);
      moveSpeedScalar = val;
      document.getElementById('move-speed-value').textContent = val.toFixed(1);
    };
    
    window.updateVoxelRes = function() {
      const val = document.getElementById('voxel-resolution').value;
      document.getElementById('voxel-res-value').textContent = val;
    };
    
    window.updateFillRadius = function() {
      const val = parseFloat(document.getElementById('fill-radius').value);
      document.getElementById('fill-radius-value').textContent = val.toFixed(1);
    };
    
    // ========== Eraser Functions ==========
    window.toggleEraseMode = function() {
      eraserMode = document.getElementById('erase-mode').checked;
      eraserSphere.visible = eraserMode;
      
      // Disable patch mode if erase mode is enabled
      if (eraserMode && patchMode) {
        document.getElementById('patch-mode').checked = false;
        patchMode = false;
        patchPlane.visible = false;
      }
      
      // Only disable pointer/mouse controls when in erase mode, keep WASD movement
      if (controls.pointerControls) controls.pointerControls.enable = !eraserMode;
      // fpsMovement (WASD) stays enabled so you can navigate while erasing
      
      if (eraserMode) {
        setStatus('Erase mode: Click and drag on mesh to erase (WASD still moves camera)');
        container.style.cursor = 'crosshair';
      } else {
        setStatus('Erase mode disabled');
        container.style.cursor = 'grab';
      }
    };
    
    window.updateEraserSize = function() {
      eraserSize = parseFloat(document.getElementById('eraser-size').value);
      document.getElementById('eraser-size-value').textContent = eraserSize.toFixed(2);
      eraserSphere.scale.setScalar(eraserSize);
    };
    
    // ========== Patch Tool Functions ==========
    window.togglePatchMode = function() {
      patchMode = document.getElementById('patch-mode').checked;
      patchPlane.visible = patchMode;
      
      // Disable erase mode if patch mode is enabled
      if (patchMode && eraserMode) {
        document.getElementById('erase-mode').checked = false;
        toggleEraseMode();
      }
      
      // Disable pointer controls when in patch mode
      if (controls.pointerControls) controls.pointerControls.enable = !patchMode;
      
      if (patchMode) {
        setStatus('Patch mode: Click to place. I/K=pitch, J/L=yaw, U/O=roll, Y/H=distance. WASD to move.');
        container.style.cursor = 'crosshair';
      } else {
        setStatus('Patch mode disabled');
        container.style.cursor = 'grab';
      }
    };
    
    window.updatePatchSize = function() {
      patchSize = parseFloat(document.getElementById('patch-size').value);
      document.getElementById('patch-size-value').textContent = patchSize.toFixed(2);
      patchPlane.scale.setScalar(patchSize);
    };
    
    window.updatePatchRotation = function() {
      patchRotX = parseFloat(document.getElementById('patch-rot-x').value);
      patchRotY = parseFloat(document.getElementById('patch-rot-y').value);
      patchRotZ = parseFloat(document.getElementById('patch-rot-z').value);
      
      document.getElementById('patch-rot-x-value').textContent = patchRotX + '°';
      document.getElementById('patch-rot-y-value').textContent = patchRotY + '°';
      document.getElementById('patch-rot-z-value').textContent = patchRotZ + '°';
      
      // Apply rotation to patch plane
      patchPlane.rotation.set(
        THREE.MathUtils.degToRad(patchRotX),
        THREE.MathUtils.degToRad(patchRotY),
        THREE.MathUtils.degToRad(patchRotZ)
      );
    };
    
    window.updatePatchDistance = function() {
      patchDistance = parseFloat(document.getElementById('patch-distance').value);
      document.getElementById('patch-distance-value').textContent = patchDistance.toFixed(3);
    };
    
    window.resetPatchRotation = function() {
      document.getElementById('patch-rot-x').value = 0;
      document.getElementById('patch-rot-y').value = 0;
      document.getElementById('patch-rot-z').value = 0;
      updatePatchRotation();
    };
    
    // Update patch plane position based on mouse/raycast
    function updatePatchPosition(event) {
      if (!patchMode) return;
      
      const rect = container.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // Always place at user-controlled distance along ray (no mesh snapping)
      const point = raycaster.ray.at(patchDistance, new THREE.Vector3());
      patchPlane.position.copy(point);
    }
    
    // Place a patch (add triangles to the mesh)
    function placePatch() {
      if (!patchMode) return;
      
      // Create mesh if it doesn't exist yet
      if (!generatedMesh) {
        // Create a new empty mesh
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
        geometry.setIndex([]);
        
        const material = new THREE.MeshStandardMaterial({
          color: 0x88aaff,
          side: THREE.DoubleSide,
          wireframe: document.getElementById('show-wireframe').checked
        });
        
        generatedMesh = new THREE.Mesh(geometry, material);
        generatedMesh.visible = document.getElementById('show-mesh').checked;
        scene.add(generatedMesh);
        
        document.getElementById('export-btn').disabled = false;
      }
      
      // Get the patch plane's world vertices
      const patchGeo = new THREE.PlaneGeometry(patchSize, patchSize);
      const tempMesh = new THREE.Mesh(patchGeo);
      tempMesh.position.copy(patchPlane.position);
      tempMesh.rotation.copy(patchPlane.rotation);
      tempMesh.updateMatrixWorld(true);
      
      // Get existing geometry data
      const existingPositions = generatedMesh.geometry.getAttribute('position');
      const existingIndex = generatedMesh.geometry.getIndex();
      
      const existingPosArray = existingPositions ? Array.from(existingPositions.array) : [];
      const existingIndexArray = existingIndex ? Array.from(existingIndex.array) : [];
      
      // Calculate base vertex index for new vertices
      const baseIndex = existingPosArray.length / 3;
      
      // Get patch plane vertices in world space
      const patchPositions = patchGeo.getAttribute('position');
      const patchIndex = patchGeo.getIndex();
      
      // Transform patch vertices to world space and add them
      const vertex = new THREE.Vector3();
      for (let i = 0; i < patchPositions.count; i++) {
        vertex.set(
          patchPositions.getX(i),
          patchPositions.getY(i),
          patchPositions.getZ(i)
        );
        vertex.applyMatrix4(tempMesh.matrixWorld);
        existingPosArray.push(vertex.x, vertex.y, vertex.z);
      }
      
      // Add patch indices (offset by base index)
      for (let i = 0; i < patchIndex.count; i++) {
        existingIndexArray.push(patchIndex.getX(i) + baseIndex);
      }
      
      // Dispose old geometry and create new one (fixes WebGL buffer issues)
      const oldGeometry = generatedMesh.geometry;
      const newGeometry = new THREE.BufferGeometry();
      newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(existingPosArray, 3));
      newGeometry.setIndex(existingIndexArray);
      newGeometry.computeVertexNormals();
      newGeometry.computeBoundingSphere();
      
      generatedMesh.geometry = newGeometry;
      oldGeometry.dispose();
      
      // Clean up temp geometry
      patchGeo.dispose();
      
      // Update stats
      document.getElementById('stat-verts').textContent = (existingPosArray.length / 3).toLocaleString();
      document.getElementById('stat-tris').textContent = (existingIndexArray.length / 3).toLocaleString();
      
      // Update helpers
      updateMeshHelpers();
      
      setStatus(`Patch placed. Total: ${(existingPosArray.length / 3).toLocaleString()} vertices, ${(existingIndexArray.length / 3).toLocaleString()} triangles`);
    }
    
    // Update eraser sphere position based on mouse/raycast
    function updateEraserPosition(event) {
      if (!eraserMode) return;
      
      const rect = container.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // First try to intersect with the generated mesh
      if (generatedMesh && generatedMesh.visible) {
        const intersects = raycaster.intersectObject(generatedMesh);
        if (intersects.length > 0) {
          eraserSphere.position.copy(intersects[0].point);
          return;
        }
      }
      
      // If no mesh hit, place sphere at a fixed distance along ray
      const point = raycaster.ray.at(10, new THREE.Vector3());
      eraserSphere.position.copy(point);
    }
    
    // Erase triangles within the eraser sphere
    function eraseAtPosition() {
      if (!eraserMode || !generatedMesh) return;
      
      const geometry = generatedMesh.geometry;
      const position = geometry.getAttribute('position');
      const index = geometry.getIndex();
      
      if (!index) return; // Non-indexed geometry not supported
      
      const eraserPos = eraserSphere.position;
      const eraserRadiusSq = eraserSize * eraserSize;
      
      const indices = index.array;
      const positions = position.array;
      const newIndices = [];
      
      // Check each triangle
      for (let i = 0; i < indices.length; i += 3) {
        const i0 = indices[i];
        const i1 = indices[i + 1];
        const i2 = indices[i + 2];
        
        // Get triangle vertices
        const v0 = new THREE.Vector3(positions[i0 * 3], positions[i0 * 3 + 1], positions[i0 * 3 + 2]);
        const v1 = new THREE.Vector3(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
        const v2 = new THREE.Vector3(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
        
        // Check if any vertex is within eraser sphere
        const inSphere = 
          v0.distanceToSquared(eraserPos) < eraserRadiusSq ||
          v1.distanceToSquared(eraserPos) < eraserRadiusSq ||
          v2.distanceToSquared(eraserPos) < eraserRadiusSq;
        
        // Keep triangle if NOT in sphere
        if (!inSphere) {
          newIndices.push(i0, i1, i2);
        }
      }
      
      // Update geometry with new indices
      geometry.setIndex(newIndices);
      geometry.computeBoundingSphere();
      
      // Update stats
      document.getElementById('stat-tris').textContent = (newIndices.length / 3).toLocaleString();
    }
    
    // Mouse event handlers for eraser and patch
    container.addEventListener('mousemove', (e) => {
      updateEraserPosition(e);
      updatePatchPosition(e);
      if (isErasing) {
        eraseAtPosition();
      }
    });
    
    container.addEventListener('mousedown', (e) => {
      if (eraserMode && e.button === 0) {
        isErasing = true;
        eraseAtPosition();
      }
      if (patchMode && e.button === 0) {
        placePatch();
      }
    });
    
    container.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        if (isErasing) {
          isErasing = false;
          // Update helpers after erasing is done
          updateMeshHelpers();
        }
      }
    });
    
    container.addEventListener('mouseleave', () => {
      isErasing = false;
    });
    
    window.togglePoints = function() {
      if (pointsCloud) {
        pointsCloud.visible = document.getElementById('show-points').checked;
      }
    };
    
    window.toggleMesh = function() {
      if (generatedMesh) {
        generatedMesh.visible = document.getElementById('show-mesh').checked;
      }
    };
    
    window.toggleWireframe = function() {
      if (generatedMesh) {
        generatedMesh.material.wireframe = document.getElementById('show-wireframe').checked;
      }
    };
    
    window.toggleEdges = function() {
      const showEdges = document.getElementById('show-edges').checked;
      if (showEdges && generatedMesh) {
        updateEdgesHelper();
      }
      if (edgesHelper) {
        edgesHelper.visible = showEdges;
      }
    };
    
    window.toggleVertices = function() {
      const showVertices = document.getElementById('show-vertices').checked;
      if (showVertices && generatedMesh) {
        updateVerticesCloud();
      }
      if (verticesCloud) {
        verticesCloud.visible = showVertices;
      }
    };
    
    function updateEdgesHelper() {
      // Remove existing edges helper
      if (edgesHelper) {
        scene.remove(edgesHelper);
        edgesHelper.geometry.dispose();
        edgesHelper.material.dispose();
        edgesHelper = null;
      }
      
      if (!generatedMesh) return;
      
      // Create edges geometry from mesh
      const edgesGeometry = new THREE.EdgesGeometry(generatedMesh.geometry, 1); // threshold angle in degrees
      const edgesMaterial = new THREE.LineBasicMaterial({ 
        color: 0xffff00,
        linewidth: 2,
        transparent: true,
        opacity: 0.8
      });
      
      edgesHelper = new THREE.LineSegments(edgesGeometry, edgesMaterial);
      edgesHelper.position.copy(generatedMesh.position);
      edgesHelper.rotation.copy(generatedMesh.rotation);
      edgesHelper.scale.copy(generatedMesh.scale);
      edgesHelper.visible = document.getElementById('show-edges').checked;
      scene.add(edgesHelper);
    }
    
    function updateVerticesCloud() {
      // Remove existing vertices cloud
      if (verticesCloud) {
        scene.remove(verticesCloud);
        verticesCloud.geometry.dispose();
        verticesCloud.material.dispose();
        verticesCloud = null;
      }
      
      if (!generatedMesh) return;
      
      const positions = generatedMesh.geometry.getAttribute('position');
      if (!positions) return;
      
      // Create points geometry from mesh vertices
      const pointsGeometry = new THREE.BufferGeometry();
      pointsGeometry.setAttribute('position', positions.clone());
      
      const pointsMaterial = new THREE.PointsMaterial({
        color: 0xff4444,
        size: 0.05,
        sizeAttenuation: true
      });
      
      verticesCloud = new THREE.Points(pointsGeometry, pointsMaterial);
      verticesCloud.position.copy(generatedMesh.position);
      verticesCloud.rotation.copy(generatedMesh.rotation);
      verticesCloud.scale.copy(generatedMesh.scale);
      verticesCloud.visible = document.getElementById('show-vertices').checked;
      scene.add(verticesCloud);
    }
    
    // Update helpers when mesh changes
    function updateMeshHelpers() {
      if (document.getElementById('show-edges').checked) {
        updateEdgesHelper();
      }
      if (document.getElementById('show-vertices').checked) {
        updateVerticesCloud();
      }
    }
    
    window.generateMesh = generateMesh;
    
    window.exportGLB = async function() {
      if (!generatedMesh) {
        setStatus('No mesh to export. Generate one first.');
        return;
      }
      
      setStatus('Exporting GLB...');
      
      const exportScene = new THREE.Scene();
      const exportMesh = generatedMesh.clone();
      exportMesh.material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      exportScene.add(exportMesh);
      
      const exporter = new GLTFExporter();
      exporter.parse(
        exportScene,
        (gltf) => {
          const blob = new Blob([gltf], { type: 'model/gltf-binary' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'collision-mesh.glb';
          a.click();
          URL.revokeObjectURL(url);
          setStatus('Exported collision-mesh.glb');
        },
        (error) => {
          console.error('Export error:', error);
          setStatus('Export failed: ' + error.message);
        },
        { binary: true }
      );
    };
    
    function setStatus(msg) {
      document.getElementById('status').innerHTML = msg;
    }
    
    function setProgress(percent) {
      document.getElementById('progress').style.width = percent + '%';
    }
    
    // ========== Resize ==========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // SparkControls handles input; we don't manage keys ourselves
    
    // ========== Animation Loop ==========
    let lastTime = performance.now();
    function animate(time) {
      const delta = (time - lastTime) || 16;
      lastTime = time;

      // Scale movement speed via SparkControls' fpsMovement.moveSpeed
      if (controls?.fpsMovement) {
        controls.fpsMovement.moveSpeed = moveSpeedScalar;
      }

      // Update SparkControls
      controls.update(camera);

      // Apply manual yaw from Q/E
      if (keyState.q) {
        camera.rotation.y += yawSpeed * (delta / 16);
      } else if (keyState.e) {
        camera.rotation.y -= yawSpeed * (delta / 16);
      }
      
      // Apply patch rotation from IJKL UO keys when in patch mode
      if (patchMode) {
        let rotChanged = false;
        const rotDelta = patchRotSpeed * (delta / 16);
        
        // I/K for X rotation (pitch)
        if (keyState.i) {
          patchRotX -= rotDelta;
          rotChanged = true;
        } else if (keyState.k) {
          patchRotX += rotDelta;
          rotChanged = true;
        }
        
        // J/L for Y rotation (yaw)
        if (keyState.j) {
          patchRotY -= rotDelta;
          rotChanged = true;
        } else if (keyState.l) {
          patchRotY += rotDelta;
          rotChanged = true;
        }
        
        // U/O for Z rotation (roll)
        if (keyState.u) {
          patchRotZ -= rotDelta;
          rotChanged = true;
        } else if (keyState.o) {
          patchRotZ += rotDelta;
          rotChanged = true;
        }
        
        // Y/H for distance
        const distDelta = 0.005 * (delta / 16);
        let distChanged = false;
        if (keyState.y) {
          patchDistance = Math.min(1, patchDistance + distDelta);
          distChanged = true;
        } else if (keyState.h) {
          patchDistance = Math.max(0, patchDistance - distDelta);
          distChanged = true;
        }
        if (distChanged) {
          document.getElementById('patch-distance').value = patchDistance;
          document.getElementById('patch-distance-value').textContent = patchDistance.toFixed(3);
        }
        
        // Update patch position in real-time when any key changes distance/rotation
        if (rotChanged || distChanged) {
          // Recalculate patch position along current ray
          raycaster.setFromCamera(mouse, camera);
          const point = raycaster.ray.at(patchDistance, new THREE.Vector3());
          patchPlane.position.copy(point);
        }
        
        if (rotChanged) {
          // Clamp to -180 to 180
          patchRotX = ((patchRotX + 180) % 360 + 360) % 360 - 180;
          patchRotY = ((patchRotY + 180) % 360 + 360) % 360 - 180;
          patchRotZ = ((patchRotZ + 180) % 360 + 360) % 360 - 180;
          
          // Update sliders
          document.getElementById('patch-rot-x').value = patchRotX;
          document.getElementById('patch-rot-y').value = patchRotY;
          document.getElementById('patch-rot-z').value = patchRotZ;
          document.getElementById('patch-rot-x-value').textContent = Math.round(patchRotX) + '°';
          document.getElementById('patch-rot-y-value').textContent = Math.round(patchRotY) + '°';
          document.getElementById('patch-rot-z-value').textContent = Math.round(patchRotZ) + '°';
          
          // Apply rotation to patch plane
          patchPlane.rotation.set(
            THREE.MathUtils.degToRad(patchRotX),
            THREE.MathUtils.degToRad(patchRotY),
            THREE.MathUtils.degToRad(patchRotZ)
          );
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  </script>
</body>
</html>
